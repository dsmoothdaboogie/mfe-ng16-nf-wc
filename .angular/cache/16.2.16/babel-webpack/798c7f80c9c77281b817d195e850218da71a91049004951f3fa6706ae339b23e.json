{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n(function () {\n  if (\n  // No Reflect, no classes, no need for shim because native custom elements\n  // require ES2015 classes or Reflect.\n  window.Reflect === undefined || window.customElements === undefined ||\n  // The webcomponentsjs custom elements polyfill doesn't require\n  // ES2015-compatible construction (`super()` or `Reflect.construct`).\n  window.customElements.polyfillWrapFlushCallback) {\n    return;\n  }\n  const BuiltInHTMLElement = HTMLElement;\n  /**\n   * With jscompiler's RECOMMENDED_FLAGS the function name will be optimized away.\n   * However, if we declare the function as a property on an object literal, and\n   * use quotes for the property name, then closure will leave that much intact,\n   * which is enough for the JS VM to correctly set Function.prototype.name.\n   */\n  const wrapperForTheName = {\n    'HTMLElement': function HTMLElement() {\n      return Reflect.construct(BuiltInHTMLElement, [], this.constructor);\n    }\n  };\n  window.HTMLElement = wrapperForTheName['HTMLElement'];\n  HTMLElement.prototype = BuiltInHTMLElement.prototype;\n  HTMLElement.prototype.constructor = HTMLElement;\n  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();","map":{"version":3,"names":["window","Reflect","undefined","customElements","polyfillWrapFlushCallback","BuiltInHTMLElement","HTMLElement","wrapperForTheName","construct","constructor","prototype","Object","setPrototypeOf"],"sources":["/Users/djdsmooth/Desktop/b-fresh-app/ng16-webcomponent/node_modules/@webcomponents/custom-elements/src/native-shim.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n/**\n * This shim allows elements written in, or compiled to, ES5 to work on native\n * implementations of Custom Elements v1. It sets new.target to the value of\n * this.constructor so that the native HTMLElement constructor can access the\n * current under-construction element's definition.\n */\n(function () {\n    if (\n    // No Reflect, no classes, no need for shim because native custom elements\n    // require ES2015 classes or Reflect.\n    window.Reflect === undefined ||\n        window.customElements === undefined ||\n        // The webcomponentsjs custom elements polyfill doesn't require\n        // ES2015-compatible construction (`super()` or `Reflect.construct`).\n        window.customElements.polyfillWrapFlushCallback) {\n        return;\n    }\n    const BuiltInHTMLElement = HTMLElement;\n    /**\n     * With jscompiler's RECOMMENDED_FLAGS the function name will be optimized away.\n     * However, if we declare the function as a property on an object literal, and\n     * use quotes for the property name, then closure will leave that much intact,\n     * which is enough for the JS VM to correctly set Function.prototype.name.\n     */\n    const wrapperForTheName = {\n        'HTMLElement': function HTMLElement() {\n            return Reflect.construct(BuiltInHTMLElement, [], this.constructor);\n        },\n    };\n    window.HTMLElement = wrapperForTheName['HTMLElement'];\n    HTMLElement.prototype = BuiltInHTMLElement.prototype;\n    HTMLElement.prototype.constructor = HTMLElement;\n    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);\n})();\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,YAAY;EACT;EACA;EACA;EACAA,MAAM,CAACC,OAAO,KAAKC,SAAS,IACxBF,MAAM,CAACG,cAAc,KAAKD,SAAS;EACnC;EACA;EACAF,MAAM,CAACG,cAAc,CAACC,yBAAyB,EAAE;IACjD;EACJ;EACA,MAAMC,kBAAkB,GAAGC,WAAW;EACtC;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMC,iBAAiB,GAAG;IACtB,aAAa,EAAE,SAASD,WAAWA,CAAA,EAAG;MAClC,OAAOL,OAAO,CAACO,SAAS,CAACH,kBAAkB,EAAE,EAAE,EAAE,IAAI,CAACI,WAAW,CAAC;IACtE;EACJ,CAAC;EACDT,MAAM,CAACM,WAAW,GAAGC,iBAAiB,CAAC,aAAa,CAAC;EACrDD,WAAW,CAACI,SAAS,GAAGL,kBAAkB,CAACK,SAAS;EACpDJ,WAAW,CAACI,SAAS,CAACD,WAAW,GAAGH,WAAW;EAC/CK,MAAM,CAACC,cAAc,CAACN,WAAW,EAAED,kBAAkB,CAAC;AAC1D,CAAC,EAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}